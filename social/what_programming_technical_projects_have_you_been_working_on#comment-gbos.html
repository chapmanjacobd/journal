
<p>The past couple days the "UTF-8 fairy" bit me and after going to the text encoding hospital I decided I was going to spend more time learning about segmentation.</p>
<p>Enter <a href="https://unicode.org/reports/tr29/">Unicode Standard Annex #29</a>. Ah yes. Number. Twenty. Nine. I need not repeat this sequence of syllables... but I will paste some links:</p>
<ul>
<li><a href="https://github.com/timendum/grapheme">https://github.com/timendum/grapheme</a></li>
<li><a href="https://www.bedrick.org/notes/python-icu-bindings/">https://www.bedrick.org/notes/python-icu-bindings/</a></li>
<li><a href="https://docs.rs/unicode-segmentation/latest/unicode_segmentation/">https://docs.rs/unicode-segmentation/latest/unicode_segmentation/</a></li>
</ul>
<p>Some ramblings:</p>
<p>ü§¶üèª‚Äç‚ôÇÔ∏è &lt;-- this emoji is 17 bytes long but it is only 2 spaces wide</p>
<p>‚∏ª this is the <em>triple em-dash</em>. Fear no longer that AGI has stolen your sword. It is only three bytes long. It's pretty long in the browser but only prints one-space wide in the terminal. kinda lame</p>
<p>So from these examples we can see that doing <code>len(text.encode("utf-8"))</code> is not enough if you want to determine if something will fit on the screen.</p>
<p>In the terminal, emojis and certain languages have letters that show up as more than one space. In Python you can use <code>wcwidth.wcswidth</code> to calculate how much space something will take up. That's great.</p>
<p>(Although <em>now that I know more</em> I wonder if there are edge cases like Ô∑Ω. That's <a href="https://util.unicode.org/UnicodeJsps/character.jsp?a=FDFD">a single character</a>. It shows up really long in my desktop browser, but quite small on my phone's mobile browser, and even smaller in the Terminal--wcswidth says it is one-width wide and indeed it prints one-width in the terminal)</p>
<p>But if you want to ensure that a string will not print longer than one line in the terminal, your function needs to be aware of the graphemes to decide where to truncate the text. Otherwise your US flag üá∫üá∏ can turn into üá∫, etc. This is because a lot of emoji and other text is built from other emoji/characters. This is not only emoji but some languages like Korean are particularly dependent on this behavior.</p>
<p>For text segmentation you really need to use the raw data of the UTF-8 spec to make intelligent decisions about where to cut text... but I was hesitant to add a dependency with 9 GitHub stars <a href="https://github.com/chapmanjacobd/library/commit/d0ddcbcf11cddcad06fd202dca9571d11ef383de">so I made an approximation</a>.</p>
<p>While writing this up I also came across the icu library again... a familiar name but I didn't think to check that it could work here. It is an optional dependency of <code>natsort</code> so I'm already kind of using it... Maybe someday I'll switch to using that but for now my grapheme_iter seems to work well enough!</p>

